### Synchronisation with GC suspension

Interpreter will run in GC unsafe mode. This means that suspension can happen only at certain points in the interpreter code.
* Explicit safepoints. We need to ensure that the interpreter can enter a gc safe state in a very short time. For this purpose, we will insert explicit safepoint instructions, most likely at method entry and as part of a backwards branch. The safepoint will poll whether there is a pending interruption request, in which case it will save any information that is needed by the stack walker so the frames can be processed. (for example the current `ip` will need to be flushed to the `InterpFrame` and the `InterpFrame` will need to be pushed on some tls stack to serve as the starting point of unwinding)
* Locations where we end up calling into the runtime. For example, as part of executing an opcode, we might need to call into the runtime to ensure that the class is initialized and the cctor is being run. The same rules as for explicit safepoints should apply, by saving any information needed by the stack walker.

Interpreter instruction typically read values from the interpreter stack, then proceed with the operation and in the end it might end some value back to the interpreter stack. For more complex opcodes that call into the runtime, a GC could happen in the middle of the opcode execution. All these locations where GC interruption can happen should be well defined, because we will have to enforce the rule that every object reference is refetched from the interpreter stack following a potential suspension point. Otherwise we could end up with native registers/stack containing an old ref for a moved objects. References that are being used by the opcode could also be stored in a separate memory location associated to the `GCFrame` of the native interpreter execution loop method.

The interpreter execution loop is non-recursive, meaning it can execute multiple managed methods. Each managed method on the stack will be identified by an `InterpFrame*`, that contains information to identify the section on the interpreter stack where the refs used by the method reside. If necessary, within the interpreter loop method implementation, we could allocate an additional space for temporary refs that must be precisely scanned every time during GC, by using the already existing `GCPROTECT` mechanism. As a more lightweight alternative we could also reserve a few slots on the interpreter stack (for example the first address of the interpreter stack), to be permanently used as temporary ref locations. The drawback would be that this address would be global for each interpreter execution loop, so it could be overwritten.

### Reporting GC Roots from interpreter stack

The interpreter should allocate an `InterpFrame*` on the native stack for each method that is being executed. These frames should be linked together. Each `InterpFrame*` should hold information about the current state of method execution, for example `ip` and `stack` (pointing to the interpreter stack where all interpreter vars reside, interpreter opcodes only operate on values from this separate stack). This information should enable both unwinding of frames as well as understanding the value of every single variable on the interpreter stack, if needed.

When the GC scans the roots from all threads, it will rely on the stack walker to unwind each frame on the thread and for each frame it will callback into interpreter via a `GcScanRoots` method. The interpreter will have to precisely identify which slots from the interpreter stack contain refs.

For the purpose of precisely reporting roots from interpreter frames, as a simplification, we might want to separate the ref space from the no-ref space. The mono interpreter has a var offset allocator, which allocates offsets on the interpreter stack for each variable in the code. As vars die, stack space is reused for new vars. The offset allocator will need to always maintain two separate spaces, one for refs and one for no-refs and allocate offsets for vars accordingly. We will need to make sure we zero the space reserved for ref vars, at each method entry, making this approach potentially expensive during code execution.

This simplified approach also has a problem with the way calls are implemented. In order to have efficent call dispatch, the var offset allocator makes sure that vars that are passed as arguments to a call will always be allocated at the top of the stack space so the call instruction will just receive the offset of the first argument on the interpreter stack and execution of the called method will start with that stack location as a frame base pointer. This is done so that calls don't require moving the arguments around to the right place which is very expensive. The problem is that we can not separate refs from no-refs on this param area location, since we are constrained to have the args one after the other and the same space is reused for different types of calls. This means that for each var that is a call arg, we would need to have some sort of live range that we use during GC scan time to check precisely which slots from the param area contain refs. There should only be a limited number of such call args vars alive at some point, making it less expensive. We could later decide to expand this approach to more vars, so we reduce the need to zero vars at runtime, at the cost of more processing during GC, at least for the optimized version of the method, assuming we will implement tiering at some point. My understanding is that this is what RyuJIT currently does.

### Reporting GC Roots during transitions

Various thunks will be needed to facilitate fast transitions between interpreter and compiled code. These thunks will move arguments between the interpreter stack and the native regs/stack, according to the platform's calling convention. A GC should not happen while executing such a thunk and given the thunks are simple in nature (they just copy values back and forth, without using the values from the stack/registers after the call is completed) it doesn't seem that there is any need to report roots from them. I also don't think the unwinder needs to have any particular knowledge about the existence of these frames. However, if certain GC interruptible initialization would be required during interpreter entry for example, before interpreter code execution actually starts, we will need to explicitly GC protect the object refs that have been passed over on the interpreter stack.
